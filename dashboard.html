<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poyolabs - CauldronWatch</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap');
        
        /* Local/demo font: Longalberica - expects the file at /static/assets/Longalberica-DEMO.ttf */
        @font-face {
            font-family: 'Longalberica';
            src: url('/static/assets/Longalberica-DEMO.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
        
        /* Basic styles to make it look good for a hackathon */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: url('/static/background.gif') center/cover fixed;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            cursor: url('/static/cursor.cur'), default;
            /* Fade in effect */
            opacity: 0;
            animation: fadeIn 1s ease-in forwards;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        h1 {
            font-family: 'MedievalSharp', cursive;
            color: #f7b733; /* Potion gold */
            text-align: center;
            background: rgb(41, 23, 40, 0.85);
            padding: 20px;
            border-radius: 0;
            display: inline-block;
            margin: 20px auto;
        }
        
        /* ========== NEW: User profile section ========== */
        .user-profile {
            position: fixed;
            top: 10px;
            right: 20px;
            background: rgb(41, 23, 40, 0.9);
            padding: 10px 15px;
            border-radius: 0;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 10px rgb(35, 20, 34, 0.3);
            z-index: 1000;
        }

        .user-profile img {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #f7b733;
        }

        .user-profile .user-name {
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        .user-profile .logout-btn {
            background: #e74c3c;
            color: #fff;
            border: none;
            padding: 5px 12px;
            border-radius: 0;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.3s;
        }

        .user-profile .logout-btn:hover {
            background: #c0392b;
        }
        /* ========== END NEW ========== */
        
        .container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }
        .dashboard, .agent-panel {
            background: rgb(41, 23, 40);
            border-radius: 0;
            padding: 20px;
            box-shadow: 0 4px 15px rgb(35, 20, 34);
        }
        h2 {
            font-family: 'MedievalSharp', cursive;
            border-bottom: 2px solid #f7b733;
            padding-bottom: 5px;
            text-align: center;
        }
        h3 {
            font-family: 'MedievalSharp', cursive;
            text-align: center;
        }

        /* Cauldron fullness GIF styles */
        .cauldron-gif-container {
            margin-top: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .cauldron-gif {
            width: 100%;
            max-width: 140px;
            height: auto;
            display: block;
            image-rendering: auto;
            border-radius: 0;
        }
        
        /* Cauldron Styles */
        #cauldron-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }
        .cauldron {
            background: #3a3a6e;
            padding: 10px;
            border-radius: 0;
            text-align: center;
            /* Add transition for smooth border color changes */
            transition: border 0.5s ease;
            border: 2px solid transparent;
        }
        .cauldron.anomaly {
            background: #e74c3c; /* Red for anomaly */
            color: #fff;
            animation: pulse 1s infinite;
            border: 2px solid transparent; /* Clear other borders if anomaly */
        }
        /* Warning borders */
        .cauldron.warning-90 { border: 2px solid #f39c12; }
        .cauldron.warning-75 { border: 2px solid #f1c40f; }

        .cauldron-name { 
            font-family: 'Longalberica', serif;
            font-weight: bold; 
        }

        /* Agent Chat Styles */
        #chat-log {
            height: 300px;
            overflow-y: auto;
            background: #1a1a2e;
            padding: 10px;
            border-radius: 0;
            margin-bottom: 10px;
        }
        #chat-log div {
            margin-bottom: 8px;
        }
        .chat-user { 
            color: #82aaff;
            background-color: #3d4968;
            padding: 5px;
            border-radius: 0;
         }
        .chat-agent { 
            color: #3d4968;
            background-color: #c3e88d; 
            padding: 5px;
            border-radius: 0;
        }
        .chat-agent-plan {
            color: #888;
            font-style: italic;
            font-size: 0.9em;
            padding-left: 15px;
            border-left: 2px solid #888;
        }
        #chat-input {
            width: calc(100% - 10px);
            padding: 8px;
            border: none;
            border-radius: 0;
            background: #3a3a6e;
            color: #fff;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }
        /* Layout toggle buttons */
        .layout-btn {
            background: #22293b; 
            color: #fff; 
            border-radius: 0; 
            padding: 8px 14px; 
            border: 2px solid #2f3a55; 
            cursor: pointer; 
            margin-right: 6px;
            font-weight: 500;
            transition: all 0.2s ease;
        }
        .layout-btn:hover {
            background: #2f3a55;
            border-color: #3d4968;
        }
        .layout-btn.active { 
            background: #f7b733; 
            color: #111; 
            border-color: #f0c65a;
            font-weight: 600;
        }
        button {
            background: #5a5f9e;
            color: #fff;
            border: none;
            border-radius: 0;
            padding: 8px 12px;
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s ease;
        }
        button:hover {
            background: #6d73b0;
        }
    </style>
</head>
<body>

    <!-- ========== NEW: User Profile Widget ========== -->
    <div class="user-profile" id="user-profile" style="display:none;">
        <img id="user-avatar" src="" alt="User">
        <span class="user-name" id="user-name">Loading...</span>
        <button class="logout-btn" onclick="logout()">Logout</button>
    </div>
    <!-- ========== END NEW ========== -->

    <div style="text-align:center;">
        <h1>
            <img src="/static/potion.png" alt="Potion" style="width:48px;height:48px;vertical-align:middle;margin-right:12px;">
            Poyolabs Factory Monitor
            <img src="/static/potion.png" alt="Potion" style="width:48px;height:48px;vertical-align:middle;margin-left:12px;">
        </h1>
    </div>

    <div class="container">
        <div class="dashboard">
            <h2>Cauldron Dashboard</h2>
            <div style="display:flex;gap:16px;align-items:flex-start">
                <div style="flex:2;min-width:0">
                    <div id="cauldron-grid"></div>
                </div>
                <div style="flex:1;min-width:400px;max-width:550px">
                    <h3>Network Map</h3>
                    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
                        <div>
                            <button id="layout-radial" class="layout-btn active">Radial</button>
                            <button id="layout-force" class="layout-btn">Force</button>
                        </div>
                        <div style="color:#c8d0e0;font-size:13px">Layout:</div>
                    </div>
                    <div id="network-map" style="background:#111229;padding:12px;border-radius:0;height:420px;overflow:hidden;position:relative"></div>
                    <h3 style="margin-top:12px">Historic Playback</h3>
                    <div>
                        <label>Date: <input type="date" id="play-date"></label>
                        <button id="play-btn">Play</button>
                        <button id="stop-btn">Stop</button>
                    </div>
                    <div style="margin-top:8px">
                        <button id="run-match">Run Ticket Matching</button>
                        <button id="optimize-routes" style="margin-left:8px">Optimize Routes</button>
                        <button id="reset-drains" style="margin-left:8px;background:#e74c3c;border-color:#c0392b" title="Clear all active drains">Reset Drains</button>
                        <button id="export-suspicious" style="margin-left:8px;display:none">Export Suspicious</button>
                    </div>
                    <div id="match-results" style="margin-top:8px;max-height:300px;overflow:auto;background:#0f1220;padding:8px;border-radius:0;color:#ddd"></div>
                </div>
            </div>
        </div>

        <div class="agent-panel">
            <h2>Poyo Pal</h2>
            <div id="chat-log">
                <div class="chat-agent">ðŸ¤– Welcome, Manager. I am monitoring the factory and will alert you to any issues.</div>
            </div>
            <form id="chat-form">
                <input type="text" id="chat-input" placeholder="Ask your agent..." autocomplete="off">
            </form>
        </div>
    </div>

    <script>
        // ========== NEW: User Profile Functions ==========
        async function loadUserProfile() {
            try {
                const response = await fetch('/api/user');
                if (response.ok) {
                    const user = await response.json();
                    document.getElementById('user-name').textContent = user.name || user.email || 'User';
                    document.getElementById('user-avatar').src = user.picture || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(user.name || 'User');
                    document.getElementById('user-profile').style.display = 'flex';
                }
            } catch (error) {
                console.log('Not logged in or error fetching user:', error);
            }
        }

        function logout() {
            window.location.href = '/logout';
        }

        // Load user profile on page load
        loadUserProfile();
        // ========== END NEW ==========

        // Get all the HTML elements we need
        const cauldronGrid = document.getElementById('cauldron-grid');
        const chatLog = document.getElementById('chat-log');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        
        // Map a percent full to the appropriate GIF from /static
        function getCauldronGif(percent) {
            const p = Math.max(0, Math.min(100, Number(percent || 0)));
            if (p <= 20) return '/static/ten.gif';
            if (p <= 40) return '/static/twenty.gif';
            if (p <= 55) return '/static/fourty.gif';
            if (p <= 70) return '/static/sixty.gif';
            if (p <= 85) return '/static/eighty.gif';
            return '/static/hundred.gif';
        }
        
        // --- 1. EOG: Render the Cauldron Dashboard ---
        
        async function updateCauldronLevels() {
            try {
                const response = await fetch('/api/cauldron/status');
                const cauldrons = await response.json();

                // Clock sync: use the server 'as_of' field from the first record (if present)
                if (Array.isArray(cauldrons) && cauldrons.length>0 && cauldrons[0].as_of) {
                    const serverAsOf = new Date(cauldrons[0].as_of).getTime();
                    const clientNow = Date.now();
                    window._serverClockOffsetMs = serverAsOf - clientNow;
                }

                // Update in-place to avoid recreating DOM nodes every poll
                for (const data of cauldrons) {
                    const id = data.id;
                    const currentLevel = Number(data.current_level || 0);
                    const maxVolume = Number(data.max_volume || 1);
                    const percent = Math.max(0, Math.min(100, Number(data.percent_full || ((currentLevel / maxVolume) * 100))));

                    let cauldronEl = cauldronGrid.querySelector(`.cauldron[data-id="${id}"]`);
                    const percentPerSec = (data.fill_rate_per_min && maxVolume) ? (Number(data.fill_rate_per_min)/60.0)/Number(maxVolume)*100.0 : null;

                    // compute server absolute fullAt
                    let serverFullAt = null;
                    if (data.full_at) {
                        serverFullAt = new Date(data.full_at).getTime();
                    } else if (data.as_of && data.time_to_full_seconds != null) {
                        serverFullAt = new Date(data.as_of).getTime() + (Number(data.time_to_full_seconds) * 1000);
                    } else if (data.time_to_full_seconds != null) {
                        serverFullAt = Date.now() + (Number(data.time_to_full_seconds) * 1000);
                    }

                    // If element doesn't exist, create it and append
                    if (!cauldronEl) {
                        cauldronEl = document.createElement('div');
                        cauldronEl.classList.add('cauldron');
                        cauldronEl.setAttribute('data-id', id);
                        cauldronEl.innerHTML = `
                            <div class="cauldron-name">${data.name}</div>
                            <div class="cauldron-percent">${percent.toFixed(1)}% Full</div>
                            <small class="cauldron-volume">(${currentLevel.toFixed(0)}L / ${maxVolume}L)</small>
                            <div class="cauldron-gif-container">
                                <img class="cauldron-gif" src="${getCauldronGif(percent)}" alt="Cauldron fullness">
                            </div>
                            <div style="margin-top:8px;font-size:0.9em;color:#ddd">Time to full: <strong class="time-to-fill">â€”</strong></div>
                            <div class="discrepancy-badge" style="display:none;margin-top:4px;font-size:0.8em;color:#ff6b6b;font-weight:bold;">âš  Discrepancy</div>
                            <div class="drain-status" style="display:none;margin-top:4px;font-size:0.85em;color:#4facf7;font-weight:bold;">ðŸš› Draining: <span class="drain-percent">0%</span></div>
                        `;
                        cauldronGrid.appendChild(cauldronEl);
                    } else {
                        // update anomaly/alert styling
                        if (data.anomaly) cauldronEl.classList.add('anomaly'); else cauldronEl.classList.remove('anomaly');
                        if (percent >= 90) {
                            cauldronEl.style.border = '2px solid #f39c12';
                        } else if (percent >= 75) {
                            cauldronEl.style.border = '2px solid #f1c40f';
                        } else {
                            cauldronEl.style.border = '';
                        }
                        // update texts and gif
                        const pctEl = cauldronEl.querySelector('.cauldron-percent');
                        const volEl = cauldronEl.querySelector('.cauldron-volume');
                        const gifEl = cauldronEl.querySelector('.cauldron-gif');
                        if (pctEl) pctEl.textContent = `${percent.toFixed(1)}% Full`;
                        if (volEl) volEl.textContent = `(${currentLevel.toFixed(0)}L / ${maxVolume}L)`;
                        if (gifEl) {
                            const newSrc = getCauldronGif(percent);
                            if (gifEl.getAttribute('src') !== newSrc) gifEl.setAttribute('src', newSrc);
                        }
                        
                        // show discrepancy badge if marked
                        const badge = cauldronEl.querySelector('.discrepancy-badge');
                        if (badge && data.has_discrepancy) {
                            badge.style.display = 'block';
                        } else if (badge) {
                            badge.style.display = 'none';
                        }
                        
                        // show drain status if actively draining
                        const drainStatus = cauldronEl.querySelector('.drain-status');
                        const drainPercent = cauldronEl.querySelector('.drain-percent');
                        if (data.is_draining) {
                            if (drainStatus) drainStatus.style.display = 'block';
                            if (drainPercent) drainPercent.textContent = `${data.drain_progress}%`;
                            // Add blue glow to draining cauldrons
                            cauldronEl.style.boxShadow = '0 0 15px rgba(79, 172, 247, 0.6)';
                            // Blue glow is handled on container; gif does not change color
                        } else {
                            if (drainStatus) drainStatus.style.display = 'none';
                            cauldronEl.style.boxShadow = '';
                            // nothing to reset for gif
                        }
                    }

                    // initialize or update per-cauldron state but avoid resetting fullAt unless meaningful change
                    window._cauldronState = window._cauldronState || {};
                    const prev = window._cauldronState[id] || {};
                    if (serverFullAt) {
                        const nowAdj = Date.now() + (window._serverClockOffsetMs || 0);
                        if (!prev.fullAt) {
                            // first time seeing this cauldron - set and lock it
                            prev.fullAt = serverFullAt;
                            prev.initialTotalSeconds = Math.max(1, Math.round((prev.fullAt - nowAdj)/1000));
                            prev.startPercent = percent;
                            prev.currentPercent = percent;
                        } else {
                            const delta = serverFullAt - prev.fullAt;
                            // ONLY update fullAt if there's a MAJOR change indicating a real event
                            // (like a drain starting, or cauldron being refilled)
                            // Check if percent changed significantly (>5%) - indicates real change
                            const percentDelta = Math.abs(percent - (prev.currentPercent || percent));
                            
                            if (percentDelta > 5) {
                                // Significant level change detected - accept new fullAt
                                prev.fullAt = serverFullAt;
                                prev.initialTotalSeconds = Math.max(1, Math.round((prev.fullAt - nowAdj)/1000));
                                prev.startPercent = percent;
                                prev.currentPercent = percent;
                            }
                            // Otherwise, ignore server fullAt changes - let client countdown run smoothly
                        }
                    }
                    prev.percentPerSec = percentPerSec;
                    window._cauldronState[id] = prev;
                }
            } catch (error) {
                console.error('Error fetching cauldron levels:', error);
            }
        }

        // Per-second updater: smoothly update time-to-fill and percent while polling runs every 5s
        window._cauldronState = window._cauldronState || {};
        setInterval(() => {
            try {
                const now = Date.now() + (window._serverClockOffsetMs || 0);
                for (const [id, s] of Object.entries(window._cauldronState)) {
                    const el = document.querySelector(`.cauldron[data-id="${id}"]`);
                    if (!el) continue;
                    if (!s.fullAt) continue; // no forecast

                    const remaining = Math.max(0, Math.round((s.fullAt - now) / 1000));
                    const tEl = el.querySelector('.time-to-fill');
                    if (tEl) {
                        const h = Math.floor(remaining / 3600);
                        const m = Math.floor((remaining % 3600) / 60);
                        const sec = remaining % 60;
                        const str = h>0 ? `${h}h ${m}m ${sec}s` : (m>0 ? `${m}m ${sec}s` : `${sec}s`);
                        tEl.textContent = remaining === 0 ? 'Full' : str;
                    }

                    // update percent by elapsed time since initialTotalSeconds
                    if (s.percentPerSec && s.initialTotalSeconds) {
                        const elapsed = Math.max(0, s.initialTotalSeconds - remaining);
                        const newPercent = Math.min(100, (s.startPercent || 0) + (s.percentPerSec * elapsed));
                        const gifEl = el.querySelector('.cauldron-gif');
                        const pctEl = el.querySelector('.cauldron-percent');
                        if (gifEl) {
                            const newSrc = getCauldronGif(newPercent);
                            if (gifEl.getAttribute('src') !== newSrc) gifEl.setAttribute('src', newSrc);
                        }
                        if (pctEl) pctEl.textContent = `${newPercent.toFixed(1)}% Full`;
                        s.currentPercent = newPercent;
                    }
                }
            } catch (e) {
                // swallow; this is best-effort UI smoothing
            }
        }, 1000);
        
        // --- 2. NVIDIA: Handle the Agent Chat ---
        
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault(); // Stop the page from reloading
            
            const message = chatInput.value;
            if (!message) return;
            
            addChatMessage(message, 'user');
            chatInput.value = ''; // Clear the input
            
            try {
                // We send the user's message to the /api/agent/chat endpoint
                const response = await fetch('/api/agent/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // Remember to add use_nemotron: true if you want to use the NVIDIA API
                    body: JSON.stringify({ message: message, use_nemotron: true })
                });
                
                const agentData = await response.json();
                
                // Add the agent's multi-step plan (for the NVIDIA judges!)
                if (agentData.agent_plan && agentData.agent_plan.length > 0) {
                    agentData.agent_plan.forEach(step => {
                        addChatMessage(step, 'agent-plan');
                    });
                }
                
                // Add the agent's final response
                addChatMessage(agentData.agent_response, 'agent');
                
                // After the agent acts, update the dashboard
                // We call this manually to make the dispatch "action" feel instant
                updateCauldronLevels();

            } catch (error) {
                console.error('Error chatting with agent:', error);
                addChatMessage('Error connecting to the agent. Is the server running?', 'agent');
            }
        });
        
        function addChatMessage(message, sender) {
            const messageEl = document.createElement('div');
            if (sender === 'user') {
                messageEl.className = 'chat-user';
                messageEl.textContent = `ðŸ‘©â€ðŸ’» ${message}`;
            } else if (sender === 'agent') {
                messageEl.className = 'chat-agent';
                messageEl.textContent = `ðŸ¤– ${message}`;
            } else if (sender === 'agent-plan') {
                messageEl.className = 'chat-agent-plan';
                messageEl.textContent = `  ${message}`;
            }
            chatLog.appendChild(messageEl);
            chatLog.scrollTop = chatLog.scrollHeight; // Auto-scroll
        }

        // --- 3. Start the Factory! ---
        
        // Historic playback state
        let playbackTimer = null;

        // layout control
        // Fetch network map and render radial SVG
        async function loadNetwork() {
            try {
                const [resNet, resStatus] = await Promise.all([fetch('/api/network'), fetch('/api/cauldron/status')]);
                const data = await (resNet.ok ? resNet.json() : {});
                const statusList = resStatus.ok ? await resStatus.json() : [];
                const mapEl = document.getElementById('network-map');
                mapEl.innerHTML = '';

                // Force a layout calculation and use actual dimensions
                const rect = mapEl.getBoundingClientRect();
                const w = rect.width > 0 ? Math.floor(rect.width) - 24 : 500; // subtract padding
                const h = rect.height > 0 ? Math.floor(rect.height) - 24 : 396; // subtract padding

                await renderRadialNetwork(mapEl, data, statusList, w, h);
            } catch (e) {
                console.error('Could not load network', e);
            }
        }

        // Render radial layout (market in center, clients around)
        async function renderRadialNetwork(mapEl, data, statusList, w, h){
            try{
                const svgNS = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(svgNS, 'svg');
                svg.setAttribute('width', w);
                svg.setAttribute('height', h);
                svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
                svg.style.background = 'transparent';
                svg.style.cursor = 'grab';

                // Add zoom/pan support
                let scale = 1;
                let translateX = 0;
                let translateY = 0;
                let isDragging = false;
                let startX = 0;
                let startY = 0;

                const container = document.createElementNS(svgNS, 'g');
                svg.appendChild(container);

                svg.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    scale *= delta;
                    scale = Math.max(0.5, Math.min(3, scale)); // Limit zoom range
                    container.setAttribute('transform', `translate(${translateX},${translateY}) scale(${scale})`);
                });

                svg.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX - translateX;
                    startY = e.clientY - translateY;
                    svg.style.cursor = 'grabbing';
                });

                svg.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    translateX = e.clientX - startX;
                    translateY = e.clientY - startY;
                    container.setAttribute('transform', `translate(${translateX},${translateY}) scale(${scale})`);
                });

                svg.addEventListener('mouseup', () => {
                    isDragging = false;
                    svg.style.cursor = 'grab';
                });

                svg.addEventListener('mouseleave', () => {
                    isDragging = false;
                    svg.style.cursor = 'grab';
                });

                const cauldrons = (data && data.cauldrons) || [];
                const edges = (data && (data.edges || (data.network && data.network.edges))) || [];
                const market = (data && data.market) || { id: 'M', name: 'Market' };
                const cx = w/2, cy = h/2;

                // build fast lookup of travel times from market to client
                const travelMap = {};
                edges.forEach(e=>{
                    const from = e.from || e.src || e.u || e.a;
                    const to = e.to || e.dst || e.v || e.b;
                    const t = e.travel_time_minutes || e.travel_time || e.cost || e.time || null;
                    if (!from || !to) return;
                    travelMap[`${from}|${to}`] = t;
                    travelMap[`${to}|${from}`] = t;
                });

                // choose client nodes (exclude market id if present)
                const clients = cauldrons.filter(c=> String(c.id) !== String(market.id));
                const count = Math.max(1, clients.length);
                
                // Calculate base radius with MORE spacing - increase from 0.65 to 0.75
                const maxRadius = Math.min(w, h) / 2 - 100; // 100px total padding
                const baseRadius = maxRadius * 0.75; // Increased from 0.65 to give more space

                const positions = {};
                clients.forEach((c, idx)=>{
                    const angle = (idx / count) * 2 * Math.PI - Math.PI/2;  // Start from top
                    // Reduce travel time variation to keep nodes from overlapping
                    const t = travelMap[`${market.id}|${c.id}`] || travelMap[`${c.id}|${market.id}`];
                    const radiusVariation = t != null ? Math.min(20, Number(t) * 1.0) : 0; // Reduced from 30 and 1.5
                    const dist = baseRadius + radiusVariation;
                    const x = cx + Math.cos(angle) * dist;
                    const y = cy + Math.sin(angle) * dist;

                    // draw edge
                    const line = document.createElementNS(svgNS,'line');
                    line.setAttribute('x1', x); line.setAttribute('y1', y); 
                    line.setAttribute('x2', cx); line.setAttribute('y2', cy);
                    line.setAttribute('stroke', '#ff6f6f'); 
                    line.setAttribute('stroke-width', '2'); 
                    line.setAttribute('opacity', '0.6');
                    container.appendChild(line);

                    // distance label with better positioning
                    if (t != null) {
                        const mx = (x + cx)/2; 
                        const my = (y + cy)/2;
                        const labelBg = document.createElementNS(svgNS,'rect');
                        labelBg.setAttribute('x', mx - 18); 
                        labelBg.setAttribute('y', my - 9); 
                        labelBg.setAttribute('width', 36); 
                        labelBg.setAttribute('height', 18);
                        labelBg.setAttribute('rx', 3); 
                        labelBg.setAttribute('ry', 3); 
                        labelBg.setAttribute('fill', '#1a1d2e'); 
                        labelBg.setAttribute('stroke', '#ff6f6f'); 
                        labelBg.setAttribute('stroke-width', '1');
                        labelBg.setAttribute('opacity', '0.9');
                        container.appendChild(labelBg);
                        
                        const lbl = document.createElementNS(svgNS,'text'); 
                        lbl.setAttribute('x', mx); 
                        lbl.setAttribute('y', my + 4); 
                        lbl.setAttribute('text-anchor', 'middle'); 
                        lbl.setAttribute('font-size', '11'); 
                        lbl.setAttribute('font-weight', 'bold');
                        lbl.setAttribute('fill', '#ff9999');
                        lbl.textContent = `${t}m`; 
                        container.appendChild(lbl);
                    }

                    positions[c.id] = { x, y };
                });

                // draw client nodes on top
                clients.forEach(c => {
                    const pos = positions[c.id];
                    const g = document.createElementNS(svgNS,'g'); 
                    g.setAttribute('transform', `translate(${pos.x},${pos.y})`);
                    
                    const circ = document.createElementNS(svgNS,'circle'); 
                    circ.setAttribute('r', '16'); 
                    circ.setAttribute('fill', '#6d5bd3'); 
                    circ.setAttribute('stroke', '#fff'); 
                    circ.setAttribute('stroke-width', '2'); 
                    g.appendChild(circ);
                    
                    const text = document.createElementNS(svgNS,'text'); 
                    text.setAttribute('y', '5'); 
                    text.setAttribute('fill', '#fff'); 
                    text.setAttribute('font-size', '11'); 
                    text.setAttribute('font-weight', 'bold');
                    text.setAttribute('text-anchor', 'middle'); 
                    
                    // Shorten name if too long
                    const name = c.name || c.id;
                    const displayName = name.length > 8 ? name.substring(0, 7) + 'â€¦' : name;
                    text.textContent = displayName;
                    g.appendChild(text);
                    
                    const title = document.createElementNS(svgNS,'title');
                    title.textContent = `${c.name || c.id} (${c.id})`;
                    g.appendChild(title);
                    
                    container.appendChild(g);
                    positions[c.id].el = g;
                });

                // draw market center (larger, more prominent)
                const mg = document.createElementNS(svgNS,'g'); 
                mg.setAttribute('transform', `translate(${cx},${cy})`);
                
                const mCirc = document.createElementNS(svgNS,'circle'); 
                mCirc.setAttribute('r', '36'); 
                mCirc.setAttribute('fill', '#f7b733'); 
                mCirc.setAttribute('stroke', '#fff'); 
                mCirc.setAttribute('stroke-width', '3'); 
                mg.appendChild(mCirc);
                
                const mtxt = document.createElementNS(svgNS,'text'); 
                mtxt.setAttribute('y', '6'); 
                mtxt.setAttribute('text-anchor', 'middle'); 
                mtxt.setAttribute('fill', '#111'); 
                mtxt.setAttribute('font-size', '16'); 
                mtxt.setAttribute('font-weight', 'bold');
                mtxt.textContent = market.name || market.id || 'Market'; 
                mg.appendChild(mtxt);
                
                container.appendChild(mg);

                // color nodes by status
                const statusMap = {};
                if (Array.isArray(statusList)) statusList.forEach(s=>{ statusMap[s.id]=Number(s.percent_full||((s.current_level||0)/(s.max_volume||1))*100); });
                function percentToColor(p){ p=Math.max(0,Math.min(100,p)); if(p<=75){ const t=p/75; const r=Math.round(76+(241-76)*t); const g=Math.round(175+(196-175)*t); const b=Math.round(247+(15-247)*t); return `rgb(${r},${g},${b})`; } else { const t=(p-75)/25; const r=Math.round(241+(231-241)*t); const g=Math.round(196+(76-196)*t); const b=Math.round(15+(60-15)*t); return `rgb(${r},${g},${b})`; } }
                Object.keys(positions).forEach(id=>{ const p=positions[id]; const pct = statusMap[id]; const circ = p.el.querySelector('circle'); if(circ){ circ.setAttribute('fill', typeof pct==='number' ? percentToColor(pct) : '#6d5bd3'); } const title = p.el.querySelector('title'); if(title){ title.textContent = `${id} â€” ${pct!=null?pct.toFixed(1)+'%':'N/A'}`; } });

                mapEl.appendChild(svg);
                window._networkSvg = svg;
                window._networkPositions = positions;
            }catch(e){ console.error('radial render failed', e); }
        }

        // --- Greedy route optimizer (client-side prototype) ---
        async function computeGreedyRoutes() {
            try {
                const resNet = await fetch('/api/network');
                const net = await resNet.json();
                const resStatus = await fetch('/api/cauldron/status');
                const stat = await resStatus.json();
                const statusMap = {};
                stat.forEach(s => { statusMap[s.id] = s; });

                const positions = window._networkPositions || {};
                const svg = window._networkSvg;
                if (!svg) {
                    alert('Network not loaded yet');
                    return;
                }

                // couriers available
                const couriers = (net.couriers && net.couriers.length) || (net.couriers ? 1 : 1);
                const market = net.market || net.market || { id: 'market', latitude: 0, longitude: 0 };
                // build list of urgent cauldrons sorted by time to full
                const urgent = Object.keys(statusMap).map(id => ({ id, s: statusMap[id] }))
                    .filter(x => x.s && (x.s.time_to_full_seconds != null))
                    .sort((a,b) => Number(a.s.time_to_full_seconds) - Number(b.s.time_to_full_seconds));

                // clear existing route layer
                const prevRoutes = svg.querySelectorAll('.route');
                prevRoutes.forEach(n => n.remove());

                const colors = ['#ff7f50','#7fffd4','#ffd700','#ff69b4','#87cefa','#a0e7a0'];
                const routes = [];

                // greedy assignment: each courier gets the next most urgent cauldron
                for (let i=0;i<Math.max(1,couriers);i++) {
                    const pick = urgent.shift();
                    if (!pick) break;
                    const cid = pick.id;
                    const pos = positions[cid];
                    // market position fallback
                    const marketPos = positions[market.id] || { x: svg.viewBox.baseVal.width/2 || (svg.clientWidth/2), y: 20 };
                    if (!pos) continue;

                    // draw a route polyline market -> cauldron -> market
                    const routeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
                    routeGroup.setAttribute('class','route');
                    const path = document.createElementNS('http://www.w3.org/2000/svg','polyline');
                    const pts = `${marketPos.x},${marketPos.y} ${pos.x},${pos.y} ${marketPos.x},${marketPos.y}`;
                    path.setAttribute('points', pts);
                    path.setAttribute('fill','none');
                    path.setAttribute('stroke', colors[i % colors.length]);
                    path.setAttribute('stroke-width','3');
                    path.setAttribute('opacity','0.9');
                    routeGroup.appendChild(path);

                    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
                    label.setAttribute('x', (marketPos.x + pos.x)/2);
                    label.setAttribute('y', (marketPos.y + pos.y)/2 - 8);
                    label.setAttribute('fill', colors[i % colors.length]);
                    label.setAttribute('font-size','11');
                    label.setAttribute('text-anchor','middle');
                    // compute simple ETA using travel_time if edge exists
                    let travel = null;
                    // find edge
                    const allEdges = net.edges || (net.network && net.network.edges) || [];
                    const edge = allEdges.find(e => (e.from===market.id && e.to===cid) || (e.to===market.id && e.from===cid));
                    if (edge) travel = edge.travel_time_minutes || edge.travel_time || edge.cost || edge.time;
                    label.textContent = `ETA: ${travel != null ? travel + 'm' : 'n/a'}`;
                    routeGroup.appendChild(label);

                    svg.appendChild(routeGroup);
                    routes.push({ courier: i+1, cauldron: cid, travel });
                }

                // show routes summary
                const matchResults = document.getElementById('match-results');
                matchResults.innerHTML = '<b>Planned Routes</b><br>' + routes.map(r => `Courier ${r.courier}: ${r.cauldron} (${r.travel||'n/a'} min)`).join('<br>');
            } catch (err) {
                console.error('Route optimizer failed', err);
                alert('Route optimizer failed: ' + err);
            }
        }

        async function playHistoric(dateStr) {
            if (!dateStr) {
                alert('Please select a date first.');
                return;
            }
            
            console.log('Fetching historic data for:', dateStr);
            
            try {
                // fetch the full day's historic samples
                const res = await fetch(`/api/data/historic?start=${dateStr}&end=${dateStr}`);
                
                if (!res.ok) {
                    alert(`Error fetching data: ${res.status} ${res.statusText}`);
                    return;
                }
                
                const samples = await res.json();
                console.log('Received samples:', samples.length);
                
                if (!Array.isArray(samples) || samples.length === 0) {
                    alert('No historic data for that date.');
                    return;
                }
                
                // Get the cauldron grid element
                const cauldronGrid = document.getElementById('cauldron-grid');
                if (!cauldronGrid) {
                    console.error('Cauldron grid not found!');
                    alert('Error: Cauldron grid not found');
                    return;
                }

                // Show playback indicator
                const playIndicator = document.createElement('div');
                playIndicator.id = 'playback-indicator';
                playIndicator.style.cssText = 'position:fixed;top:10px;right:10px;background:#4facf7;color:#fff;padding:8px 16px;border-radius:0;z-index:1000;font-weight:bold;';
                playIndicator.textContent = `â–¶ Playing ${dateStr} (0/${samples.length})`;
                document.body.appendChild(playIndicator);

                // Normalize: if records are full objects with cauldron_levels, we'll step through them
                let i = 0;
                if (playbackTimer) clearInterval(playbackTimer);
                
                playbackTimer = setInterval(() => {
                    const rec = samples[i];
                    
                    // Update indicator
                    playIndicator.textContent = `â–¶ Playing ${dateStr} (${i + 1}/${samples.length})`;
                    
                    // if record has cauldron_levels, replace the grid with snapshot
                    if (rec && rec.cauldron_levels) {
                        // build temporary snapshot objects similar to /api/cauldron/status
                        const snapshot = [];
                        const staticCauldrons = window.staticCauldrons || [];
                        
                        for (const sc of staticCauldrons) {
                            const id = sc.id;
                            snapshot.push({
                                id: id,
                                name: sc.name,
                                current_level: rec.cauldron_levels[id] || 0,
                                max_volume: sc.max_volume || 1,
                                anomaly: (rec.cauldron_levels[id] || 0) >= (sc.max_volume || 1),
                                percent_full: ((rec.cauldron_levels[id] || 0) / (sc.max_volume || 1)) * 100
                            });
                        }
                        
                        // render snapshot into grid using in-place updates (avoid clearing DOM)
                        for (const data of snapshot) {
                            const id = data.id;
                            let cauldronEl = cauldronGrid.querySelector(`.cauldron[data-id="${id}"]`);
                            if (!cauldronEl) {
                                cauldronEl = document.createElement('div');
                                cauldronEl.classList.add('cauldron');
                                cauldronEl.setAttribute('data-id', id);
                                cauldronEl.innerHTML = `
                                    <div class="cauldron-name">${data.name}</div>
                                    <div class="cauldron-percent">${data.percent_full.toFixed(1)}% Full</div>
                                    <small class="cauldron-volume">(${(data.current_level||0).toFixed(0)}L / ${data.max_volume}L)</small>
                                    <div class="cauldron-gif-container"><img class="cauldron-gif" src="${getCauldronGif(data.percent_full)}" alt="Cauldron fullness"></div>
                                    <div style="margin-top:8px;font-size:0.9em;color:#ddd">Time to full: <strong class="time-to-fill">â€”</strong></div>
                                `;
                                cauldronGrid.appendChild(cauldronEl);
                            } else {
                                // update existing element
                                if (data.anomaly) cauldronEl.classList.add('anomaly'); else cauldronEl.classList.remove('anomaly');
                                const pctEl = cauldronEl.querySelector('.cauldron-percent');
                                const volEl = cauldronEl.querySelector('.cauldron-volume');
                                const gifEl = cauldronEl.querySelector('.cauldron-gif');
                                if (pctEl) pctEl.textContent = `${data.percent_full.toFixed(1)}% Full`;
                                if (volEl) volEl.textContent = `(${(data.current_level||0).toFixed(0)}L / ${data.max_volume}L)`;
                                if (gifEl) {
                                    const newSrc = getCauldronGif(data.percent_full);
                                    if (gifEl.getAttribute('src') !== newSrc) gifEl.setAttribute('src', newSrc);
                                }
                            }
                            // ensure playback doesn't show stale fullAt-based timers
                            const state = window._cauldronState = window._cauldronState || {};
                            state[id] = state[id] || {};
                            state[id].fullAt = null;
                            const el = cauldronGrid.querySelector(`.cauldron[data-id="${id}"]`);
                            const tEl = el && el.querySelector('.time-to-fill');
                            if (tEl) tEl.textContent = 'â€”';
                        }
                    }

                    i++;
                    if (i >= samples.length) {
                        clearInterval(playbackTimer);
                        playbackTimer = null;
                        playIndicator.textContent = 'âœ“ Playback Complete';
                        setTimeout(() => {
                            playIndicator.remove();
                        }, 2000);
                    }
                }, 800);
                
            } catch (error) {
                console.error('Playback error:', error);
                alert('Playback error: ' + error.message);
            }
        }

        document.getElementById('play-btn').addEventListener('click', () => {
            const d = document.getElementById('play-date').value;
            playHistoric(d);
        });
        document.getElementById('stop-btn').addEventListener('click', () => {
            if (playbackTimer) { clearInterval(playbackTimer); playbackTimer = null; }
        });

        document.getElementById('run-match').addEventListener('click', async () => {
            const out = document.getElementById('match-results');
            out.innerHTML = '<div style="color:#aaa">Loading...</div>';
            try {
                const res = await fetch('/api/tickets/match');
                const data = await res.json();
                out.innerHTML = '';
                if (data.error) { 
                    out.innerHTML = `<div style="color:#ff6b6b">Error: ${data.error}</div>`; 
                    return; 
                }
                
                const matches = data.matches || [];
                const suspicious = matches.filter(m => m.suspicious);
                const ok = matches.filter(m => !m.suspicious);
                
                // Summary header
                const summary = document.createElement('div');
                summary.style.padding = '8px';
                summary.style.background = 'rgba(255,255,255,0.05)';
                summary.style.borderRadius = '4px';
                summary.style.marginBottom = '8px';
                summary.innerHTML = `<strong>Ticket Analysis</strong><br/>
                    <span style="color:#9ad18a">${ok.length} Valid</span> â€¢ 
                    <span style="color:#ff6b6b">${suspicious.length} Suspicious</span>`;
                out.appendChild(summary);
                
                // Show suspicious first
                if (suspicious.length > 0) {
                    const h = document.createElement('div');
                    h.style.marginTop = '8px';
                    h.style.fontWeight = 'bold';
                    h.style.color = '#ff6b6b';
                    h.textContent = `âš  ${suspicious.length} Suspicious Tickets`;
                    out.appendChild(h);
                    
                    // Show top 10 suspicious with details, rest collapsed
                    const topSuspicious = suspicious.slice(0, 10);
                    const restSuspicious = suspicious.slice(10);
                    
                    topSuspicious.forEach(m => {
                        const div = document.createElement('div');
                        div.style.padding = '8px';
                        div.style.margin = '4px 0';
                        div.style.background = 'rgba(255,107,107,0.1)';
                        div.style.border = '1px solid rgba(255,107,107,0.3)';
                        div.style.borderRadius = '4px';
                        div.style.fontSize = '0.9em';
                        
                        const diff = m.difference || 0;
                        const diffColor = diff > 0 ? '#ff6b6b' : '#ffa726';
                        const diffText = diff > 0 ? `Over-claimed by ${diff}L` : `Under-claimed by ${Math.abs(diff)}L`;
                        
                        div.innerHTML = `
                            <div style="display:flex;justify-content:space-between;margin-bottom:4px">
                                <strong style="color:#fff">${m.cauldron_id}</strong>
                                <span style="color:#888">Ticket #${m.ticket_id || 'N/A'}</span>
                            </div>
                            <div style="display:grid;grid-template-columns:1fr 1fr;gap:4px;margin:6px 0">
                                <div><span style="color:#888">Claimed:</span> <strong>${m.ticket_amount || 'N/A'}L</strong></div>
                                <div><span style="color:#888">Actual:</span> <strong>${m.calculated_amount || 'N/A'}L</strong></div>
                            </div>
                            <div style="color:${diffColor};font-weight:bold;font-size:0.95em;margin-top:4px">${diffText}</div>
                            <div style="color:#999;font-size:0.85em;margin-top:4px">${m.reason}</div>
                        `;
                        out.appendChild(div);
                    });
                    
                    if (restSuspicious.length > 0) {
                        const moreToggle = document.createElement('div');
                        moreToggle.style.marginTop = '8px';
                        moreToggle.style.cursor = 'pointer';
                        moreToggle.style.color = '#ff9999';
                        moreToggle.style.fontSize = '0.9em';
                        moreToggle.innerHTML = `+ ${restSuspicious.length} more suspicious tickets (click to show)`;
                        
                        const moreContainer = document.createElement('div');
                        moreContainer.style.display = 'none';
                        
                        restSuspicious.forEach(m => {
                            const div = document.createElement('div');
                            div.style.padding = '4px';
                            div.style.margin = '2px 0';
                            div.style.background = 'rgba(255,107,107,0.05)';
                            div.style.borderRadius = '3px';
                            div.style.fontSize = '0.85em';
                            div.innerHTML = `${m.cauldron_id} â€” Ticket: ${m.ticket_amount}L, Actual: ${m.calculated_amount}L, Diff: ${m.difference}L`;
                            moreContainer.appendChild(div);
                        });
                        
                        moreToggle.addEventListener('click', () => {
                            if (moreContainer.style.display === 'none') {
                                moreContainer.style.display = 'block';
                                moreToggle.innerHTML = `- Hide ${restSuspicious.length} more suspicious tickets`;
                            } else {
                                moreContainer.style.display = 'none';
                                moreToggle.innerHTML = `+ ${restSuspicious.length} more suspicious tickets (click to show)`;
                            }
                        });
                        
                        out.appendChild(moreToggle);
                        out.appendChild(moreContainer);
                    }
                    
                    // Show export button
                    document.getElementById('export-suspicious').style.display = 'inline-block';
                    document.getElementById('export-suspicious').onclick = () => {
                        const csv = 'Ticket ID,Cauldron,Claimed (L),Actual (L),Difference (L),Reason\n' +
                            suspicious.map(m => 
                                `${m.ticket_id || 'N/A'},${m.cauldron_id},${m.ticket_amount || 'N/A'},${m.calculated_amount || 'N/A'},${m.difference || 'N/A'},"${m.reason}"`
                            ).join('\n');
                        const blob = new Blob([csv], { type: 'text/csv' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `suspicious_tickets_${new Date().toISOString().split('T')[0]}.csv`;
                        a.click();
                    };
                }
                
                // Show valid tickets (collapsed by default)
                if (ok.length > 0) {
                    const toggle = document.createElement('div');
                    toggle.style.marginTop = '12px';
                    toggle.style.cursor = 'pointer';
                    toggle.style.color = '#9ad18a';
                    toggle.style.fontWeight = 'bold';
                    toggle.innerHTML = `âœ“ ${ok.length} Valid Tickets (click to expand)`;
                    
                    const validContainer = document.createElement('div');
                    validContainer.style.display = 'none';
                    validContainer.style.marginTop = '4px';
                    
                    ok.forEach(m => {
                        const div = document.createElement('div');
                        div.style.padding = '6px';
                        div.style.margin = '2px 0';
                        div.style.fontSize = '0.9em';
                        div.style.background = 'rgba(154,209,138,0.05)';
                        div.style.borderRadius = '3px';
                        div.style.borderLeft = '2px solid #9ad18a';
                        div.style.paddingLeft = '8px';
                        const diff = m.difference || 0;
                        const matchQuality = Math.abs(diff) < 1 ? 'Perfect' : Math.abs(diff) < 3 ? 'Good' : 'Acceptable';
                        div.innerHTML = `
                            <div><strong>${m.cauldron_id}</strong> â€” Ticket #${m.ticket_id || 'N/A'}</div>
                            <div style="color:#aaa;font-size:0.85em;margin-top:2px">
                                Claimed: ${m.ticket_amount}L, Actual: ${m.calculated_amount}L, Diff: ${Math.abs(diff).toFixed(2)}L
                                <span style="color:#9ad18a;margin-left:8px">(${matchQuality})</span>
                            </div>
                        `;
                        validContainer.appendChild(div);
                    });
                    
                    toggle.addEventListener('click', () => {
                        if (validContainer.style.display === 'none') {
                            validContainer.style.display = 'block';
                            toggle.innerHTML = `âœ“ ${ok.length} Valid Tickets (click to collapse)`;
                        } else {
                            validContainer.style.display = 'none';
                            toggle.innerHTML = `âœ“ ${ok.length} Valid Tickets (click to expand)`;
                        }
                    });
                    
                    out.appendChild(toggle);
                    out.appendChild(validContainer);
                }
                
                // Show unmatched drains
                if ((data.unmatched_drains || []).length > 0) {
                    const h = document.createElement('div');
                    h.style.marginTop = '12px';
                    h.style.fontWeight = 'bold';
                    h.style.color = '#f39c12';
                    h.textContent = 'âš  Unmatched Drain Events';
                    out.appendChild(h);
                    
                    (data.unmatched_drains || []).forEach(u => {
                        const d = document.createElement('div');
                        d.style.fontSize = '0.85em';
                        d.style.marginTop = '4px';
                        d.style.padding = '4px';
                        d.style.background = 'rgba(243,156,18,0.1)';
                        d.style.borderLeft = '3px solid #f39c12';
                        d.textContent = `${u.cauldron_id} on ${u.day}: ${u.event.drained}L drained (${u.event.duration_min}min)`;
                        out.appendChild(d);
                    });
                }
                
                // Mark cauldrons with discrepancies
                suspicious.forEach(m => {
                    const el = document.querySelector(`.cauldron[data-id="${m.cauldron_id}"]`);
                    if (el) {
                        const badge = el.querySelector('.discrepancy-badge');
                        if (badge) badge.style.display = 'block';
                    }
                });
                
            } catch (err) {
                out.innerHTML = `<div style="color:#ff6b6b">Error: ${err.message}</div>`;
            }
        });

        document.getElementById('optimize-routes').addEventListener('click', async () => {
            try {
                // ask server to compute optimized routes
                const res = await fetch('/api/optimizer/compute');
                const plan = await res.json();
                const svg = window._networkSvg;
                const positions = window._networkPositions || {};
                if (!svg) { alert('Load network first'); return; }

                // clear previous route layers
                const prev = svg.querySelectorAll('.route'); prev.forEach(n=>n.remove());

                if (plan.error) {
                    alert('Optimizer error: ' + plan.error);
                    return;
                }

                const colors = ['#ff7f50','#7fffd4','#ffd700','#ff69b4','#87cefa','#a0e7a0','#f08080','#dda0dd'];
                const out = document.getElementById('match-results');
                out.innerHTML = `<b>Optimizer: ${plan.required_couriers} couriers required</b><br>`;

                (plan.routes || []).forEach((r, idx) => {
                    const seq = r.sequence || [];
                    const pts = [];
                    const marketPos = positions[ (window.staticCauldrons && window.staticCauldrons.market && window.staticCauldrons.market.id) || 'market' ] || null;
                    // fallback to center top
                    const fallbackMarket = { x: svg.viewBox.baseVal.width/2 || (svg.clientWidth/2), y: 18 };
                    const mpos = positions[(window._networkPositions && Object.keys(window._networkPositions)[0]) ? Object.keys(window._networkPositions)[0] : 'market'] || fallbackMarket;
                    // start at market
                    pts.push([mpos.x, mpos.y]);
                    seq.forEach(cid => {
                        const p = positions[cid];
                        if (p) pts.push([p.x, p.y]);
                    });
                    pts.push([mpos.x, mpos.y]);

                    // draw polyline
                    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
                    g.setAttribute('class','route');
                    const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
                    poly.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
                    poly.setAttribute('fill','none');
                    poly.setAttribute('stroke', colors[idx % colors.length]);
                    poly.setAttribute('stroke-width','3');
                    poly.setAttribute('opacity','0.95');
                    g.appendChild(poly);

                    // add label
                    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
                    const mid = pts[Math.floor(pts.length/2)];
                    lbl.setAttribute('x', mid[0]); lbl.setAttribute('y', mid[1]-8);
                    lbl.setAttribute('fill', colors[idx % colors.length]);
                    lbl.setAttribute('font-size','11');
                    lbl.setAttribute('text-anchor','middle');
                    lbl.textContent = `Courier ${r.courier}` + (r.impossible ? ' (!!)' : '');
                    g.appendChild(lbl);

                    // svg.appendChild(g);
                    const container = svg.querySelector('g');
                    if (container) {
                        container.appendChild(g);
                    }
                    else {
                        svg.appendChild(g);
                    }
                    
                    out.innerHTML += `Courier ${r.courier}: ${seq.join(' â†’ ')}${r.impossible ? ' â€” UNREACHABLE' : ''}<br>`;
                });

            } catch (err) {
                console.error(err);
                alert('Optimizer failed: ' + err);
            }
        });

        // Reset Drains button handler
        document.getElementById('reset-drains').addEventListener('click', async () => {
            if (!confirm('Clear all active drains? This will stop all courier operations.')) {
                return;
            }
            
            try {
                const res = await fetch('/api/drains/reset', { method: 'POST' });
                const data = await res.json();
                
                if (data.status === 'success') {
                    alert(`âœ… ${data.message}`);
                    // Refresh the dashboard to show cleared drains
                    updateCauldronLevels();
                } else {
                    alert(`âŒ Error: ${data.error || 'Unknown error'}`);
                }
            } catch (err) {
                console.error('Reset failed:', err);
                alert('âŒ Failed to reset drains: ' + err);
            }
        });

        // Update the levels when the page loads
        updateCauldronLevels();
        // Also load network and save static cauldrons in window for playback
        loadNetwork().then(() => {
            fetch('/api/network').then(r=>r.json()).then(d=>{ window.staticCauldrons = d.cauldrons || []; });
        });
        
        // Keep the dashboard live-updating (like the EOG spec)
        setInterval(updateCauldronLevels, 5000); // Update every 5 seconds
        
        // ========== NEW: Proactive Agent Insights ==========
        async function fetchProactiveInsights() {
            try {
                const res = await fetch('/api/agent/insights');
                if (!res.ok) return;
                
                const data = await res.json();
                const insights = data.insights || [];
                
                if (insights.length === 0) {
                    // Hide insights panel if no insights
                    document.getElementById('agent-insights').style.display = 'none';
                    return;
                }
                
                // Show insights panel
                const insightsPanel = document.getElementById('agent-insights');
                const container = document.getElementById('insights-container');
                insightsPanel.style.display = 'block';
                
                // Clear old insights
                container.innerHTML = '';
                
                // Display insights
                insights.forEach(insight => {
                    const div = document.createElement('div');
                    div.style.padding = '6px 8px';
                    div.style.margin = '4px 0';
                    div.style.borderRadius = '4px';
                    div.style.fontSize = '0.9em';
                    
                    // Color based on severity
                    if (insight.severity === 'URGENT' || insight.severity === 'HIGH') {
                        div.style.background = 'rgba(255,107,107,0.15)';
                        div.style.borderLeft = '3px solid #ff6b6b';
                    } else if (insight.severity === 'MEDIUM') {
                        div.style.background = 'rgba(255,193,7,0.15)';
                        div.style.borderLeft = '3px solid #ffc107';
                    } else {
                        div.style.background = 'rgba(154,209,138,0.15)';
                        div.style.borderLeft = '3px solid #9ad18a';
                    }
                    
                    div.innerHTML = `
                        <div style="font-weight:bold;margin-bottom:2px;color:#fff">${insight.type}</div>
                        <div>${insight.message}</div>
                    `;
                    
                    // Add action button if available
                    if (insight.action && insight.cauldron) {
                        const actionBtn = document.createElement('button');
                        actionBtn.textContent = `Execute: ${insight.action}`;
                        actionBtn.style.marginTop = '6px';
                        actionBtn.style.padding = '4px 8px';
                        actionBtn.style.fontSize = '0.85em';
                        actionBtn.style.background = '#4facf7';
                        actionBtn.style.border = 'none';
                        actionBtn.style.borderRadius = '3px';
                        actionBtn.style.cursor = 'pointer';
                        actionBtn.style.color = '#fff';
                        
                        actionBtn.addEventListener('click', () => {
                            // Auto-send command to agent
                            const chatInput = document.getElementById('chat-input');
                            chatInput.value = `${insight.action} for ${insight.cauldron}`;
                            document.getElementById('chat-form').dispatchEvent(new Event('submit'));
                        });
                        
                        div.appendChild(actionBtn);
                    }
                    
                    container.appendChild(div);
                });
                
                // Also add to chat log as agent message
                if (insights.length > 0 && insights.some(i => i.severity === 'URGENT' || i.severity === 'HIGH')) {
                    const chatLog = document.getElementById('chat-log');
                    const urgentCount = insights.filter(i => i.severity === 'URGENT' || i.severity === 'HIGH').length;
                    const agentMsg = document.createElement('div');
                    agentMsg.classList.add('chat-agent');
                    agentMsg.innerHTML = `ðŸš¨ <strong>Alert:</strong> I've detected ${urgentCount} urgent ${urgentCount === 1 ? 'issue' : 'issues'} requiring your attention. Check the insights panel above.`;
                    chatLog.appendChild(agentMsg);
                    chatLog.scrollTop = chatLog.scrollHeight;
                }
                
            } catch (err) {
                console.error('Failed to fetch proactive insights:', err);
            }
        }
        
        // Fetch insights on page load and every 30 seconds
        fetchProactiveInsights();
        setInterval(fetchProactiveInsights, 30000);
    </script>
</body>
</html>