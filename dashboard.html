<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poyolabs - CauldronWatch</title>
    <link rel="icon" type="image/png" href="/static/potion.ico" size="32x32">
    <style>
        /* Basic styles to make it look good for a hackathon */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #f7b733; /* Potion gold */
            text-align: center;
        }
        
        /* ========== NEW: User profile section ========== */
        .user-profile {
            position: fixed;
            top: 10px;
            right: 20px;
            background: rgba(42, 42, 78, 0.9);
            padding: 10px 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }

        .user-profile img {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid #f7b733;
        }

        .user-profile .user-name {
            color: #e0e0e0;
            font-size: 0.9rem;
        }

        .user-profile .logout-btn {
            background: #e74c3c;
            color: #fff;
            border: none;
            padding: 5px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.3s;
        }

        .user-profile .logout-btn:hover {
            background: #c0392b;
        }
        /* ========== END NEW ========== */
        
        .container {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
        }
        .dashboard, .agent-panel {
            background: #2a2a4e;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        h2 {
            border-bottom: 2px solid #f7b733;
            padding-bottom: 5px;
        }
        
        /* Cauldron Styles */
        #cauldron-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
        }
        .cauldron {
            background: #3a3a6e;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            /* Add transition for smooth border color changes */
            transition: border 0.5s ease;
            border: 2px solid transparent;
        }
        .cauldron.anomaly {
            background: #e74c3c; /* Red for anomaly */
            color: #fff;
            animation: pulse 1s infinite;
            border: 2px solid transparent; /* Clear other borders if anomaly */
        }
        /* Warning borders */
        .cauldron.warning-90 { border: 2px solid #f39c12; }
        .cauldron.warning-75 { border: 2px solid #f1c40f; }

        .cauldron-name { font-weight: bold; }
        .level-bar-container {
            background: #1a1a2e;
            border-radius: 5px;
            height: 20px;
            overflow: hidden;
            margin-top: 10px;
        }
        .level-bar {
            height: 100%;
            background: linear-gradient(90deg, #4facf7, #2ecc71);
            width: 0%; /* Will be set by JS */
            transition: width 0.5s ease;
        }

        /* Agent Chat Styles */
        #chat-log {
            height: 300px;
            overflow-y: auto;
            background: #1a1a2e;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        #chat-log div {
            margin-bottom: 8px;
        }
        .chat-user { color: #82aaff; }
        .chat-agent { color: #c3e88d; }
        .chat-agent-plan {
            color: #888;
            font-style: italic;
            font-size: 0.9em;
            padding-left: 15px;
            border-left: 2px solid #888;
        }
        #chat-input {
            width: calc(100% - 10px);
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: #3a3a6e;
            color: #fff;
        }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
            100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
        }
    </style>
</head>
<body>

    <!-- ========== NEW: User Profile Widget ========== -->
    <div class="user-profile" id="user-profile" style="display:none;">
        <img id="user-avatar" src="" alt="User">
        <span class="user-name" id="user-name">Loading...</span>
        <button class="logout-btn" onclick="logout()">Logout</button>
    </div>
    <!-- ========== END NEW ========== -->

    <h1>ðŸ”® Poyolabs Factory Monitor</h1>

    <div class="container">
        <div class="dashboard">
            <h2>CauldronWatch Dashboard</h2>
            <div style="display:flex;gap:12px;align-items:flex-start">
                <div style="flex:1">
                    <div id="cauldron-grid"></div>
                </div>
                <div style="width:300px">
                    <h3>Network Map</h3>
                    <div id="network-map" style="background:#111229;padding:8px;border-radius:6px;height:300px;overflow:auto"></div>
                    <h3 style="margin-top:12px">Historic Playback</h3>
                    <div>
                        <label>Date: <input type="date" id="play-date"></label>
                        <button id="play-btn">Play</button>
                        <button id="stop-btn">Stop</button>
                    </div>
                    <div style="margin-top:8px">
                        <button id="run-match">Run Ticket Matching</button>
                        <button id="optimize-routes" style="margin-left:8px">Optimize Routes</button>
                    </div>
                    <div id="match-results" style="margin-top:8px;max-height:200px;overflow:auto;background:#0f1220;padding:8px;border-radius:6px;color:#ddd"></div>
                </div>
            </div>
        </div>

        <div class="agent-panel">
            <h2>Poyolabs Agent</h2>
            <div id="chat-log">
                <div class="chat-agent">Welcome, Manager. I am monitoring the factory. What do you need?</div>
            </div>
            <form id="chat-form">
                <input type="text" id="chat-input" placeholder="Ask your agent..." autocomplete="off">
            </form>
        </div>
    </div>

    <script>
        // ========== NEW: User Profile Functions ==========
        async function loadUserProfile() {
            try {
                const response = await fetch('/api/user');
                if (response.ok) {
                    const user = await response.json();
                    document.getElementById('user-name').textContent = user.name || user.email || 'User';
                    document.getElementById('user-avatar').src = user.picture || 'https://ui-avatars.com/api/?name=' + encodeURIComponent(user.name || 'User');
                    document.getElementById('user-profile').style.display = 'flex';
                }
            } catch (error) {
                console.log('Not logged in or error fetching user:', error);
            }
        }

        function logout() {
            window.location.href = '/logout';
        }

        // Load user profile on page load
        loadUserProfile();
        // ========== END NEW ==========

        // Get all the HTML elements we need
        const cauldronGrid = document.getElementById('cauldron-grid');
        const chatLog = document.getElementById('chat-log');
        const chatForm = document.getElementById('chat-form');
        const chatInput = document.getElementById('chat-input');
        
        // --- 1. EOG: Render the Cauldron Dashboard ---
        
        async function updateCauldronLevels() {
            try {
                const response = await fetch('/api/cauldron/status');
                const cauldrons = await response.json();

                // Clock sync: use the server 'as_of' field from the first record (if present)
                if (Array.isArray(cauldrons) && cauldrons.length>0 && cauldrons[0].as_of) {
                    const serverAsOf = new Date(cauldrons[0].as_of).getTime();
                    const clientNow = Date.now();
                    window._serverClockOffsetMs = serverAsOf - clientNow;
                }

                // Update in-place to avoid recreating DOM nodes every poll
                for (const data of cauldrons) {
                    const id = data.id;
                    const currentLevel = Number(data.current_level || 0);
                    const maxVolume = Number(data.max_volume || 1);
                    const percent = Math.max(0, Math.min(100, Number(data.percent_full || ((currentLevel / maxVolume) * 100))));

                    let cauldronEl = cauldronGrid.querySelector(`.cauldron[data-id="${id}"]`);
                    const percentPerSec = (data.fill_rate_per_min && maxVolume) ? (Number(data.fill_rate_per_min)/60.0)/Number(maxVolume)*100.0 : null;

                    // compute server absolute fullAt
                    let serverFullAt = null;
                    if (data.full_at) {
                        serverFullAt = new Date(data.full_at).getTime();
                    } else if (data.as_of && data.time_to_full_seconds != null) {
                        serverFullAt = new Date(data.as_of).getTime() + (Number(data.time_to_full_seconds) * 1000);
                    } else if (data.time_to_full_seconds != null) {
                        serverFullAt = Date.now() + (Number(data.time_to_full_seconds) * 1000);
                    }

                    // If element doesn't exist, create it and append
                    if (!cauldronEl) {
                        cauldronEl = document.createElement('div');
                        cauldronEl.classList.add('cauldron');
                        cauldronEl.setAttribute('data-id', id);
                        cauldronEl.innerHTML = `
                            <div class="cauldron-name">${data.name}</div>
                            <div class="cauldron-percent">${percent.toFixed(1)}% Full</div>
                            <small class="cauldron-volume">(${currentLevel.toFixed(0)}L / ${maxVolume}L)</small>
                            <div class="level-bar-container">
                                <div class="level-bar" style="width: ${percent}%"></div>
                            </div>
                            <div style="margin-top:8px;font-size:0.9em;color:#ddd">Time to full: <strong class="time-to-fill">â€”</strong></div>
                        `;
                        cauldronGrid.appendChild(cauldronEl);
                    } else {
                        // update anomaly/alert styling
                        if (data.anomaly) cauldronEl.classList.add('anomaly'); else cauldronEl.classList.remove('anomaly');
                        if (percent >= 90) {
                            cauldronEl.style.border = '2px solid #f39c12';
                        } else if (percent >= 75) {
                            cauldronEl.style.border = '2px solid #f1c40f';
                        } else {
                            cauldronEl.style.border = '';
                        }
                        // update texts and bar
                        const pctEl = cauldronEl.querySelector('.cauldron-percent');
                        const volEl = cauldronEl.querySelector('.cauldron-volume');
                        const bar = cauldronEl.querySelector('.level-bar');
                        if (pctEl) pctEl.textContent = `${percent.toFixed(1)}% Full`;
                        if (volEl) volEl.textContent = `(${currentLevel.toFixed(0)}L / ${maxVolume}L)`;
                        if (bar) bar.style.width = `${percent}%`;
                    }

                    // initialize or update per-cauldron state but avoid resetting fullAt unless meaningful change
                    window._cauldronState = window._cauldronState || {};
                    const prev = window._cauldronState[id] || {};
                    if (serverFullAt) {
                        const nowAdj = Date.now() + (window._serverClockOffsetMs || 0);
                        if (!prev.fullAt) {
                            // first time seeing this cauldron
                            prev.fullAt = serverFullAt;
                            prev.initialTotalSeconds = Math.max(1, Math.round((prev.fullAt - nowAdj)/1000));
                            prev.startPercent = percent;
                            prev.currentPercent = percent;
                        } else {
                            const delta = serverFullAt - prev.fullAt;
                            if (delta <= -2000) {
                                // significant decrease: accept immediately
                                prev.fullAt = serverFullAt;
                                prev.initialTotalSeconds = Math.max(1, Math.round((prev.fullAt - nowAdj)/1000));
                                prev.startPercent = percent;
                                prev.currentPercent = percent;
                            } else if (delta > 0) {
                                // increase: allow only a small step to avoid jumping backwards
                                const maxIncreaseMs = 5000; // allow up to 5s increase per poll
                                const allowed = Math.min(delta, maxIncreaseMs);
                                prev.fullAt = prev.fullAt + allowed;
                                prev.initialTotalSeconds = Math.max(1, Math.round((prev.fullAt - nowAdj)/1000));
                                // keep continuity by using currentPercent as starting point
                                prev.startPercent = prev.currentPercent || percent;
                            }
                        }
                    }
                    prev.percentPerSec = percentPerSec;
                    window._cauldronState[id] = prev;
                }
            } catch (error) {
                console.error('Error fetching cauldron levels:', error);
            }
        }

        // Per-second updater: smoothly update time-to-fill and percent while polling runs every 5s
        window._cauldronState = window._cauldronState || {};
        setInterval(() => {
            try {
                const now = Date.now() + (window._serverClockOffsetMs || 0);
                for (const [id, s] of Object.entries(window._cauldronState)) {
                    const el = document.querySelector(`.cauldron[data-id="${id}"]`);
                    if (!el) continue;
                    if (!s.fullAt) continue; // no forecast

                    const remaining = Math.max(0, Math.round((s.fullAt - now) / 1000));
                    const tEl = el.querySelector('.time-to-fill');
                    if (tEl) {
                        const h = Math.floor(remaining / 3600);
                        const m = Math.floor((remaining % 3600) / 60);
                        const sec = remaining % 60;
                        const str = h>0 ? `${h}h ${m}m ${sec}s` : (m>0 ? `${m}m ${sec}s` : `${sec}s`);
                        tEl.textContent = remaining === 0 ? 'Full' : str;
                    }

                    // update percent by elapsed time since initialTotalSeconds
                    if (s.percentPerSec && s.initialTotalSeconds) {
                        const elapsed = Math.max(0, s.initialTotalSeconds - remaining);
                        const newPercent = Math.min(100, (s.startPercent || 0) + (s.percentPerSec * elapsed));
                        const bar = el.querySelector('.level-bar');
                        const pctEl = el.querySelector('.cauldron-percent');
                        if (bar) bar.style.width = `${newPercent}%`;
                        if (pctEl) pctEl.textContent = `${newPercent.toFixed(1)}% Full`;
                        s.currentPercent = newPercent;
                    }
                }
            } catch (e) {
                // swallow; this is best-effort UI smoothing
            }
        }, 1000);
        
        // --- 2. NVIDIA: Handle the Agent Chat ---
        
        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault(); // Stop the page from reloading
            
            const message = chatInput.value;
            if (!message) return;
            
            addChatMessage(message, 'user');
            chatInput.value = ''; // Clear the input
            
            try {
                // We send the user's message to the /api/agent/chat endpoint
                const response = await fetch('/api/agent/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    // Remember to add use_nemotron: true if you want to use the NVIDIA API
                    body: JSON.stringify({ message: message, use_nemotron: true })
                });
                
                const agentData = await response.json();
                
                // Add the agent's multi-step plan (for the NVIDIA judges!)
                if (agentData.agent_plan && agentData.agent_plan.length > 0) {
                    agentData.agent_plan.forEach(step => {
                        addChatMessage(step, 'agent-plan');
                    });
                }
                
                // Add the agent's final response
                addChatMessage(agentData.agent_response, 'agent');
                
                // After the agent acts, update the dashboard
                // We call this manually to make the dispatch "action" feel instant
                updateCauldronLevels();

            } catch (error) {
                console.error('Error chatting with agent:', error);
                addChatMessage('Error connecting to the agent. Is the server running?', 'agent');
            }
        });
        
        function addChatMessage(message, sender) {
            const messageEl = document.createElement('div');
            if (sender === 'user') {
                messageEl.className = 'chat-user';
                messageEl.textContent = `> ${message}`;
            } else if (sender === 'agent') {
                messageEl.className = 'chat-agent';
                messageEl.textContent = `ðŸ¤– ${message}`;
            } else if (sender === 'agent-plan') {
                messageEl.className = 'chat-agent-plan';
                messageEl.textContent = `  ${message}`;
            }
            chatLog.appendChild(messageEl);
            chatLog.scrollTop = chatLog.scrollHeight; // Auto-scroll
        }

        // --- 3. Start the Factory! ---
        
        // Historic playback state
        let playbackTimer = null;

        // Fetch network map and render a simple SVG
        async function loadNetwork() {
            try {
                const res = await fetch('/api/network');
                const data = await res.json();
                const mapEl = document.getElementById('network-map');
                mapEl.innerHTML = '';
                // Simple rendering: show cauldrons with coordinates if available
                const svgNS = 'http://www.w3.org/2000/svg';
                const svg = document.createElementNS(svgNS, 'svg');
                // Size the svg to the container so coordinates scale correctly
                const w = mapEl.clientWidth || 320;
                const h = mapEl.clientHeight || 280;
                svg.setAttribute('width', w);
                svg.setAttribute('height', h);
                svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
                svg.style.background = 'transparent';

                const cauldrons = data.cauldrons || [];
                // Map lat/lon to box (with robust fallbacks)
                let minLat=90, maxLat=-90, minLon=180, maxLon=-180;
                cauldrons.forEach(c => {
                    const lat = Number(c.lat);
                    const lon = Number(c.lon);
                    if (!Number.isNaN(lat)) { minLat = Math.min(minLat, lat); maxLat = Math.max(maxLat, lat); }
                    if (!Number.isNaN(lon)) { minLon = Math.min(minLon, lon); maxLon = Math.max(maxLon, lon); }
                });
                // If no valid coordinates found, center everything
                if (minLat === 90 || maxLat === -90) { minLat = 0; maxLat = 1; }
                if (minLon === 180 || maxLon === -180) { minLon = 0; maxLon = 1; }

                const margin = 12;
                const innerW = Math.max(32, w - margin*2);
                const innerH = Math.max(32, h - margin*2);

                // Keep a small map of used positions to apply jitter to overlapping nodes
                const used = {};
                const positions = {}; // id -> {x,y,el}

                cauldrons.forEach((c, idx) => {
                    const lat = Number(c.lat);
                    const lon = Number(c.lon);
                    // Fallback to center if this cauldron lacks coords
                    const lonVal = Number.isNaN(lon) ? (minLon + maxLon) / 2 : lon;
                    const latVal = Number.isNaN(lat) ? (minLat + maxLat) / 2 : lat;

                    const xRaw = ((lonVal - minLon) / (maxLon - minLon || 1)) * innerW + margin;
                    const yRaw = ((maxLat - latVal) / (maxLat - minLat || 1)) * innerH + margin;
                    // Round positions and apply tiny jitter if colliding
                    let x = Math.round(xRaw);
                    let y = Math.round(yRaw);
                    const key = `${x},${y}`;
                    if (used[key]) {
                        // apply small deterministic jitter based on index
                        const jitter = ((idx % 6) - 3) * 4;
                        x += jitter;
                        y += Math.floor(jitter/2);
                    }
                    used[`${x},${y}`] = true;

                    const g = document.createElementNS(svgNS, 'g');
                    const circle = document.createElementNS(svgNS,'circle');
                    circle.setAttribute('cx', x);
                    circle.setAttribute('cy', y);
                    circle.setAttribute('r', 8);
                    circle.setAttribute('fill','#4facf7');
                    circle.setAttribute('stroke','#fff');
                    circle.setAttribute('stroke-width','0.8');
                    circle.style.cursor = 'pointer';
                    g.appendChild(circle);

                    // add a title for hover (accessibility)
                    const title = document.createElementNS(svgNS, 'title');
                    title.textContent = `${c.name || c.id} (${c.id || ''})`;
                    g.appendChild(title);

                    const label = document.createElementNS(svgNS,'text');
                    // clamp label position to avoid overflow
                    const labelX = Math.min(x + 12, w - 60);
                    const labelY = Math.min(y + 4, h - 6);
                    label.setAttribute('x', labelX);
                    label.setAttribute('y', labelY);
                    label.setAttribute('fill','#ddd');
                    label.setAttribute('font-size','11');
                    label.textContent = c.name || c.id;
                    g.appendChild(label);

                    svg.appendChild(g);

                    // store position for edge drawing and coloring
                    positions[c.id] = { x: x, y: y, el: g };
                });

                // Draw edges (if present) beneath nodes
                const edges = data.edges || (data.network && data.network.edges) || [];
                if (Array.isArray(edges) && edges.length>0) {
                    const edgeGroup = document.createElementNS(svgNS, 'g');
                    edgeGroup.setAttribute('class','edges');
                    edges.forEach(e => {
                        const fromId = e.from || e.src || e.u || e.a;
                        const toId = e.to || e.dst || e.v || e.b;
                        if (!fromId || !toId) return;
                        const p1 = positions[fromId];
                        const p2 = positions[toId];
                        if (!p1 || !p2) return;
                        const line = document.createElementNS(svgNS, 'line');
                        line.setAttribute('x1', p1.x);
                        line.setAttribute('y1', p1.y);
                        line.setAttribute('x2', p2.x);
                        line.setAttribute('y2', p2.y);
                        line.setAttribute('stroke', '#55607a');
                        // scale stroke by travel time where possible
                        const rawT = e.travel_time_minutes || e.travel_time || e.cost || e.time || 1;
                        const tnum = Number(rawT) || 1;
                        const strokeW = Math.max(1, Math.min(6, Math.round(tnum / 2)));
                        line.setAttribute('stroke-width', String(strokeW));
                        line.setAttribute('opacity', '0.9');
                        // attach tooltip
                        const etitle = document.createElementNS(svgNS, 'title');
                        etitle.textContent = `from ${fromId} â†’ ${toId}` + (rawT ? ` (${rawT} min)` : '');
                        line.appendChild(etitle);
                        edgeGroup.appendChild(line);

                        const tt = e.travel_time_minutes || e.travel_time || e.cost || e.time || null;
                        if (tt != null) {
                            const lx = (p1.x + p2.x)/2;
                            const ly = (p1.y + p2.y)/2;
                            const tlabel = document.createElementNS(svgNS, 'text');
                            tlabel.setAttribute('x', lx);
                            tlabel.setAttribute('y', ly - 6);
                            tlabel.setAttribute('fill', '#aab');
                            tlabel.setAttribute('font-size', '10');
                            tlabel.setAttribute('text-anchor','middle');
                            tlabel.textContent = String(tt);
                            edgeGroup.appendChild(tlabel);
                        }
                    });
                    svg.insertBefore(edgeGroup, svg.firstChild);
                }

                // color nodes by current fill percent using /api/cauldron/status
                try {
                    const statusRes = await fetch('/api/cauldron/status');
                    const statusList = await statusRes.json();
                    const statusMap = {};
                    if (Array.isArray(statusList)) {
                        statusList.forEach(s => { statusMap[s.id] = Number(s.percent_full || ((s.current_level||0)/(s.max_volume||1))*100); });
                    }

                    function percentToColor(p) {
                        p = Math.max(0, Math.min(100, p));
                        if (p <= 75) {
                            const t = p/75;
                            const r = Math.round(76 + (241-76)*t);
                            const g = Math.round(175 + (196-175)*t);
                            const b = Math.round(247 + (15-247)*t);
                            return `rgb(${r},${g},${b})`;
                        } else {
                            const t = (p-75)/25;
                            const r = Math.round(241 + (231-241)*t);
                            const g = Math.round(196 + (76-196)*t);
                            const b = Math.round(15 + (60-15)*t);
                            return `rgb(${r},${g},${b})`;
                        }
                    }

                    Object.keys(positions).forEach(id => {
                        const pos = positions[id];
                        const pct = statusMap[id];
                        const circle = pos && pos.el && pos.el.querySelector('circle');
                        if (circle) {
                            if (typeof pct === 'number') {
                                circle.setAttribute('fill', percentToColor(pct));
                            } else {
                                circle.setAttribute('fill', '#4facf7');
                            }
                        }
                        // attach hover tooltip details for nodes
                        try {
                            const nodeTitle = pos.el.querySelector('title');
                            const details = [];
                            const pctTxt = typeof pct === 'number' ? `${pct.toFixed(1)}%` : 'N/A';
                            details.push(`Fill: ${pctTxt}`);
                            const s = statusList && statusList.find(x=>x.id===id);
                            if (s) {
                                if (s.fill_rate_per_min) details.push(`Fill rate: ${s.fill_rate_per_min} L/min`);
                                if (s.drain_rate_per_min) details.push(`Drain rate: ${s.drain_rate_per_min} L/min`);
                                if (s.time_to_full_seconds != null) details.push(`TtF: ${Math.round(Number(s.time_to_full_seconds))}s`);
                            }
                            if (nodeTitle) nodeTitle.textContent = `${nodeTitle.textContent}\n${details.join(' | ')}`;
                        } catch (e) {
                            // ignore
                        }
                    });
                } catch (err) {
                    console.warn('Could not fetch cauldron status for coloring:', err);
                }

                mapEl.appendChild(svg);
                // store current svg for route drawing
                window._networkSvg = svg;
                window._networkPositions = positions;
            } catch (e) {
                console.error('Could not load network', e);
            }
        }

        // --- Greedy route optimizer (client-side prototype) ---
        async function computeGreedyRoutes() {
            try {
                const resNet = await fetch('/api/network');
                const net = await resNet.json();
                const resStatus = await fetch('/api/cauldron/status');
                const stat = await resStatus.json();
                const statusMap = {};
                stat.forEach(s => { statusMap[s.id] = s; });

                const positions = window._networkPositions || {};
                const svg = window._networkSvg;
                if (!svg) {
                    alert('Network not loaded yet');
                    return;
                }

                // couriers available
                const couriers = (net.couriers && net.couriers.length) || (net.couriers ? 1 : 1);
                const market = net.market || net.market || { id: 'market', latitude: 0, longitude: 0 };
                // build list of urgent cauldrons sorted by time to full
                const urgent = Object.keys(statusMap).map(id => ({ id, s: statusMap[id] }))
                    .filter(x => x.s && (x.s.time_to_full_seconds != null))
                    .sort((a,b) => Number(a.s.time_to_full_seconds) - Number(b.s.time_to_full_seconds));

                // clear existing route layer
                const prevRoutes = svg.querySelectorAll('.route');
                prevRoutes.forEach(n => n.remove());

                const colors = ['#ff7f50','#7fffd4','#ffd700','#ff69b4','#87cefa','#a0e7a0'];
                const routes = [];

                // greedy assignment: each courier gets the next most urgent cauldron
                for (let i=0;i<Math.max(1,couriers);i++) {
                    const pick = urgent.shift();
                    if (!pick) break;
                    const cid = pick.id;
                    const pos = positions[cid];
                    // market position fallback
                    const marketPos = positions[market.id] || { x: svg.viewBox.baseVal.width/2 || (svg.clientWidth/2), y: 20 };
                    if (!pos) continue;

                    // draw a route polyline market -> cauldron -> market
                    const routeGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
                    routeGroup.setAttribute('class','route');
                    const path = document.createElementNS('http://www.w3.org/2000/svg','polyline');
                    const pts = `${marketPos.x},${marketPos.y} ${pos.x},${pos.y} ${marketPos.x},${marketPos.y}`;
                    path.setAttribute('points', pts);
                    path.setAttribute('fill','none');
                    path.setAttribute('stroke', colors[i % colors.length]);
                    path.setAttribute('stroke-width','3');
                    path.setAttribute('opacity','0.9');
                    routeGroup.appendChild(path);

                    const label = document.createElementNS('http://www.w3.org/2000/svg','text');
                    label.setAttribute('x', (marketPos.x + pos.x)/2);
                    label.setAttribute('y', (marketPos.y + pos.y)/2 - 8);
                    label.setAttribute('fill', colors[i % colors.length]);
                    label.setAttribute('font-size','11');
                    label.setAttribute('text-anchor','middle');
                    // compute simple ETA using travel_time if edge exists
                    let travel = null;
                    // find edge
                    const allEdges = net.edges || (net.network && net.network.edges) || [];
                    const edge = allEdges.find(e => (e.from===market.id && e.to===cid) || (e.to===market.id && e.from===cid));
                    if (edge) travel = edge.travel_time_minutes || edge.travel_time || edge.cost || edge.time;
                    label.textContent = `ETA: ${travel != null ? travel + 'm' : 'n/a'}`;
                    routeGroup.appendChild(label);

                    svg.appendChild(routeGroup);
                    routes.push({ courier: i+1, cauldron: cid, travel });
                }

                // show routes summary
                const matchResults = document.getElementById('match-results');
                matchResults.innerHTML = '<b>Planned Routes</b><br>' + routes.map(r => `Courier ${r.courier}: ${r.cauldron} (${r.travel||'n/a'} min)`).join('<br>');
            } catch (err) {
                console.error('Route optimizer failed', err);
                alert('Route optimizer failed: ' + err);
            }
        }

        async function playHistoric(dateStr) {
            if (!dateStr) return;
            // fetch the full day's historic samples
            const res = await fetch(`/api/data/historic?start=${dateStr}&end=${dateStr}`);
            const samples = await res.json();
            if (!Array.isArray(samples) || samples.length===0) {
                alert('No historic data for that date.');
                return;
            }

            // Normalize: if records are full objects with cauldron_levels, we'll step through them
            let i = 0;
            if (playbackTimer) clearInterval(playbackTimer);
            playbackTimer = setInterval(() => {
                const rec = samples[i];
                // if record has cauldron_levels, replace the grid with snapshot
                if (rec.cauldron_levels) {
                    // build temporary snapshot objects similar to /api/cauldron/status
                    const snapshot = [];
                    const staticCauldrons = window.staticCauldrons || [];
                    for (const sc of staticCauldrons) {
                        const id = sc.id;
                        snapshot.push({
                            id: id,
                            name: sc.name,
                            current_level: rec.cauldron_levels[id] || 0,
                            max_volume: sc.max_volume || 1,
                            anomaly: (rec.cauldron_levels[id] || 0) >= (sc.max_volume || 1),
                            percent_full: ((rec.cauldron_levels[id] || 0) / (sc.max_volume || 1)) * 100
                        });
                    }
                    // render snapshot into grid using in-place updates (avoid clearing DOM)
                    for (const data of snapshot) {
                        const id = data.id;
                        let cauldronEl = cauldronGrid.querySelector(`.cauldron[data-id="${id}"]`);
                        if (!cauldronEl) {
                            cauldronEl = document.createElement('div');
                            cauldronEl.classList.add('cauldron');
                            cauldronEl.setAttribute('data-id', id);
                            cauldronEl.innerHTML = `
                                <div class="cauldron-name">${data.name}</div>
                                <div class="cauldron-percent">${data.percent_full.toFixed(1)}% Full</div>
                                <small class="cauldron-volume">(${(data.current_level||0).toFixed(0)}L / ${data.max_volume}L)</small>
                                <div class="level-bar-container"><div class="level-bar" style="width:${data.percent_full}%"></div></div>
                                <div style="margin-top:8px;font-size:0.9em;color:#ddd">Time to full: <strong class="time-to-fill">â€”</strong></div>
                            `;
                            cauldronGrid.appendChild(cauldronEl);
                        } else {
                            // update existing element
                            if (data.anomaly) cauldronEl.classList.add('anomaly'); else cauldronEl.classList.remove('anomaly');
                            const pctEl = cauldronEl.querySelector('.cauldron-percent');
                            const volEl = cauldronEl.querySelector('.cauldron-volume');
                            const bar = cauldronEl.querySelector('.level-bar');
                            if (pctEl) pctEl.textContent = `${data.percent_full.toFixed(1)}% Full`;
                            if (volEl) volEl.textContent = `(${(data.current_level||0).toFixed(0)}L / ${data.max_volume}L)`;
                            if (bar) bar.style.width = `${data.percent_full}%`;
                        }
                        // ensure playback doesn't show stale fullAt-based timers
                        const state = window._cauldronState = window._cauldronState || {};
                        state[id] = state[id] || {};
                        state[id].fullAt = null;
                        const el = cauldronGrid.querySelector(`.cauldron[data-id="${id}"]`);
                        const tEl = el && el.querySelector('.time-to-fill');
                        if (tEl) tEl.textContent = 'â€”';
                    }
                }

                i++;
                if (i >= samples.length) {
                    clearInterval(playbackTimer); playbackTimer = null;
                }
            }, 800);
        }

        document.getElementById('play-btn').addEventListener('click', () => {
            const d = document.getElementById('play-date').value;
            playHistoric(d);
        });
        document.getElementById('stop-btn').addEventListener('click', () => {
            if (playbackTimer) { clearInterval(playbackTimer); playbackTimer = null; }
        });

        document.getElementById('run-match').addEventListener('click', async () => {
            const res = await fetch('/api/tickets/match');
            const data = await res.json();
            const out = document.getElementById('match-results');
            out.innerHTML = '';
            if (data.error) { out.textContent = data.error; return; }
            const matches = data.matches || [];
            matches.forEach(m => {
                const div = document.createElement('div');
                div.style.padding = '6px 0';
                div.style.borderBottom = '1px solid rgba(255,255,255,0.03)';
                div.innerHTML = `<strong>${m.ticket_id || '(no id)'} (${m.cauldron_id})</strong> â€” Ticket: ${m.ticket_amount || 'N/A'}L, Calculated: ${m.calculated_amount || 'N/A'}L<br/><span style="color:${m.suspicious? '#ff6b6b':'#9ad18a'}">${m.suspicious? 'SUSPICIOUS':'OK'}</span> â€” ${m.reason}`;
                out.appendChild(div);
            });
            if ((data.unmatched_drains || []).length>0) {
                const h = document.createElement('div'); h.style.marginTop='8px'; h.innerHTML = '<strong>Unmatched Drains</strong>';
                out.appendChild(h);
                (data.unmatched_drains||[]).forEach(u => {
                    const d = document.createElement('div'); d.style.fontSize='12px'; d.style.marginTop='4px';
                    d.textContent = `${u.cauldron_id} ${u.day} drained ${u.event.drained}L (from ${u.event.start} to ${u.event.end})`;
                    out.appendChild(d);
                });
            }
        });

        document.getElementById('optimize-routes').addEventListener('click', async () => {
            try {
                // ask server to compute optimized routes
                const res = await fetch('/api/optimizer/compute');
                const plan = await res.json();
                const svg = window._networkSvg;
                const positions = window._networkPositions || {};
                if (!svg) { alert('Load network first'); return; }

                // clear previous route layers
                const prev = svg.querySelectorAll('.route'); prev.forEach(n=>n.remove());

                if (plan.error) {
                    alert('Optimizer error: ' + plan.error);
                    return;
                }

                const colors = ['#ff7f50','#7fffd4','#ffd700','#ff69b4','#87cefa','#a0e7a0','#f08080','#dda0dd'];
                const out = document.getElementById('match-results');
                out.innerHTML = `<b>Optimizer: ${plan.required_couriers} couriers required</b><br>`;

                (plan.routes || []).forEach((r, idx) => {
                    const seq = r.sequence || [];
                    const pts = [];
                    const marketPos = positions[ (window.staticCauldrons && window.staticCauldrons.market && window.staticCauldrons.market.id) || 'market' ] || null;
                    // fallback to center top
                    const fallbackMarket = { x: svg.viewBox.baseVal.width/2 || (svg.clientWidth/2), y: 18 };
                    const mpos = positions[(window._networkPositions && Object.keys(window._networkPositions)[0]) ? Object.keys(window._networkPositions)[0] : 'market'] || fallbackMarket;
                    // start at market
                    pts.push([mpos.x, mpos.y]);
                    seq.forEach(cid => {
                        const p = positions[cid];
                        if (p) pts.push([p.x, p.y]);
                    });
                    pts.push([mpos.x, mpos.y]);

                    // draw polyline
                    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
                    g.setAttribute('class','route');
                    const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
                    poly.setAttribute('points', pts.map(p=>p.join(',')).join(' '));
                    poly.setAttribute('fill','none');
                    poly.setAttribute('stroke', colors[idx % colors.length]);
                    poly.setAttribute('stroke-width','3');
                    poly.setAttribute('opacity','0.95');
                    g.appendChild(poly);

                    // add label
                    const lbl = document.createElementNS('http://www.w3.org/2000/svg','text');
                    const mid = pts[Math.floor(pts.length/2)];
                    lbl.setAttribute('x', mid[0]); lbl.setAttribute('y', mid[1]-8);
                    lbl.setAttribute('fill', colors[idx % colors.length]);
                    lbl.setAttribute('font-size','11');
                    lbl.setAttribute('text-anchor','middle');
                    lbl.textContent = `Courier ${r.courier}` + (r.impossible ? ' (!!)' : '');
                    g.appendChild(lbl);

                    svg.appendChild(g);

                    out.innerHTML += `Courier ${r.courier}: ${seq.join(' â†’ ')}${r.impossible ? ' â€” UNREACHABLE' : ''}<br>`;
                });

            } catch (err) {
                console.error(err);
                alert('Optimizer failed: ' + err);
            }
        });

        // Update the levels when the page loads
        updateCauldronLevels();
        // Also load network and save static cauldrons in window for playback
        loadNetwork().then(() => {
            fetch('/api/network').then(r=>r.json()).then(d=>{ window.staticCauldrons = d.cauldrons || []; });
        });
        
        // Keep the dashboard live-updating (like the EOG spec)
        setInterval(updateCauldronLevels, 5000); // Update every 5 seconds
    </script>
</body>
</html>